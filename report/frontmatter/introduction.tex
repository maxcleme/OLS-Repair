\chapter*{Introduction}
	\thispagestyle{introduction}
	\addcontentsline{toc}{chapter}{Introduction}

% Introduction (5 paragraphes: contexte, problème, objectif, solution, évaluation)

%contexte
\par La réparation automatique de bugs est un domaine en pleine expansion. En effet, le nombre de programmes évolue de plus en plus chaques jours et par corrélation le nombre de bugs également. Il est envisageable dans les prochaines années que les développeurs ne soit pas assez nombreux pour résoudre tous ces bugs. C'est ici qu'intervient la réparation automatique de bugs, consistant à utiliser des programmes pour réparer d'autres programmes afin de remplacer ou guider ces développeurs.  

%probleme
\par Des approches déjà existantes\cite{genprog}\cite{semfix} ont fait leurs preuves. Elles permettent effectivement de réparer des bugs, mais leurs comportements dépendent du code fournis avec le programme défaillant. Elles appliquent des transformations sur le code jusqu'à faire passer les tests. Cependant l'utilisation de codes contenants des bugs est-il une bonne pratique pour réparer automatiquement un programme ? Une question peut alors se poser : Est-il possible de réparer des programmes tout en étant indépendant des bugs présents ?

%objectif
\par L'objectif est de montrer qu'un tel comportement est possible. La solution proposée ici est appelée OLS-Repair, elle est grandement inspirée par un outils appelé Nopol\cite{nopol}. Cette approche utilise les entrées / sorties des tests pour définir des contraintes, et essaye de les résoudre à l'aide de solver SMT\footnote{\url{https://fr.wikipedia.org/wiki/Satisfiability_modulo_theories}}.


%évaluation
\par L'évaluation a été réalisée sur un sous-ensemble de IntroclassJava, un dataset contenant des bugs réels. Afin des respecter le scope définie en \ref{sec:scope}, des transformations synthaxiques ont été effectuées. Cette évaluation met l'accent sur l'importance du nombre de tests ainsi que les constantes définies dans OLS-Repair.